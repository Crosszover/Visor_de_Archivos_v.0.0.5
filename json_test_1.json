{
    "nodos": [
        {
            "tipo": "carpeta",
            "nombre": "Board_AI_Developer",
            "x": 100.0,
            "y": 100.0,
            "datos_extra": {}
        },
        {
            "tipo": "script",
            "nombre": "Visor_de_Archivos_v.0.0.5.py",
            "x": 447.0,
            "y": 152.0,
            "datos_extra": {
                "extension": ".py",
                "contenido": "import tkinter as tk\nfrom tkinter import ttk, simpledialog, messagebox, filedialog, Menu\nimport json\nimport os\nfrom PIL import Image, ImageTk\n\nclass VisorArchivos:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Visor de Estructura de Archivos\")\n        \n        # Cargar iconos\n        self.iconos = {}\n        self.cargar_iconos()\n        \n        # Variables para el seguimiento de nodos y líneas\n        self.nodos = []\n        self.nodo_seleccionado = None\n        self.lineas = []\n        \n        # Canvas principal\n        self.canvas = tk.Canvas(root, width=800, height=600, bg='white', scrollregion=(0, 0, 2000, 2000))\n        self.canvas.pack(expand=True, fill='both')        \n        # Scrollbars\n        self.vscroll = ttk.Scrollbar(root, orient=\"vertical\", command=self.canvas.yview)\n        self.hscroll = ttk.Scrollbar(root, orient=\"horizontal\", command=self.canvas.xview)\n        self.canvas.configure(yscrollcommand=self.vscroll.set, xscrollcommand=self.hscroll.set)\n        \n        # Configurar scroll\n        self.vscroll.pack(side=\"right\", fill=\"y\")\n        self.hscroll.pack(side=\"bottom\", fill=\"x\")\n        \n        # Barra de herramientas\n        self.frame_botones = ttk.Frame(root)\n        self.frame_botones.pack(pady=5)\n        \n        ttk.Button(self.frame_botones, text=\"Importar JSON\", \n                  command=self.cargar_estructura).pack(side='left', padx=5)\n        ttk.Button(self.frame_botones, text=\"Exportar JSON\", \n                  command=self.guardar_estructura).pack(side='left', padx=5)\n        ttk.Button(self.frame_botones, text=\"Generar Archivos\", \n                  command=self.generar_archivos).pack(side='left', padx=5)\n\n        # Crear menús contextuales\n        self.crear_menus_contextuales()\n        \n        # Eventos del ratón\n        self.canvas.bind('<Button-1>', self.click_izquierdo)\n        self.canvas.bind('<B1-Motion>', self.mover_nodo)\n        self.canvas.bind('<ButtonRelease-1>', self.finalizar_movimiento)\n        self.canvas.bind('<Button-3>', self.mostrar_menu_contextual)\n\n    def cargar_iconos(self):\n        try:\n            iconos_paths = {\n                \"carpeta\": \"folder.png\",\n                \"script\": \"script.png\",\n                \"imagen\": \"image.png\"\n            }\n            \n            for tipo, path in iconos_paths.items():\n                if os.path.exists(path):\n                    imagen = Image.open(path)\n                    imagen = imagen.resize((24, 24))\n                    self.iconos[tipo] = ImageTk.PhotoImage(imagen)\n                else:\n                    print(f\"No se encontró el icono {path}\")\n            \n            if os.path.exists(\"file.png\"):\n                imagen = Image.open(\"file.png\")\n                imagen = imagen.resize((24, 24))\n                self.iconos[\"archivo\"] = ImageTk.PhotoImage(imagen)\n            \n        except Exception as e:\n            print(f\"Error al cargar iconos: {e}\")\n\n    def crear_menus_contextuales(self):\n        self.menu_canvas = Menu(self.root, tearoff=0)\n        self.menu_canvas.add_command(label=\"Crear Nodo Matriz\", \n                                   command=self.crear_nodo_matriz)\n        \n        self.menu_nodo = Menu(self.root, tearoff=0)\n        self.menu_nodo.add_command(label=\"Editar\", command=self.editar_nodo_actual)\n        self.menu_nodo.add_command(label=\"Crear Nodo Hijo\", \n                                 command=self.crear_nodo_hijo)\n        self.menu_nodo.add_separator()\n        self.menu_nodo.add_command(label=\"Eliminar (y descendientes)\", \n                                 command=self.eliminar_nodo_y_descendientes)\n\n# SUSTITUIR DESDE AQUÍ HASTA encontrar_nodo, click_izquierdo, mover_nodo Y OTROS MANEJADORES DE EVENTOS:\n\n    def encontrar_nodo(self, x, y):\n        # Convertir coordenadas del evento a coordenadas del canvas\n        x = self.canvas.canvasx(x)\n        y = self.canvas.canvasy(y)\n        \n        for nodo in self.nodos:\n            coords = self.canvas.bbox(nodo[\"rect\"])\n            if coords and coords[0] <= x <= coords[2] and coords[1] <= y <= coords[3]:\n                return nodo\n        return None\n\n    def click_izquierdo(self, event):\n        self.nodo_seleccionado = self.encontrar_nodo(event.x, event.y)\n\n    def mover_nodo(self, event):\n        if self.nodo_seleccionado:\n            # Convertir coordenadas del evento a coordenadas del canvas\n            x = self.canvas.canvasx(event.x)\n            y = self.canvas.canvasy(event.y)\n            \n            coords = self.canvas.bbox(self.nodo_seleccionado[\"rect\"])\n            dx = x - (coords[0] + 150)  # Ajustado para el nuevo ancho del nodo\n            dy = y - (coords[1] + 20)\n            \n            self.canvas.move(self.nodo_seleccionado[\"rect\"], dx, dy)\n            self.canvas.move(self.nodo_seleccionado[\"texto\"], dx, dy)\n            if self.nodo_seleccionado.get(\"icono\"):\n                self.canvas.move(self.nodo_seleccionado[\"icono\"], dx, dy)\n            \n            self.actualizar_conexiones_recursivas(self.nodo_seleccionado)\n\n    def actualizar_conexiones_recursivas(self, nodo):\n        for conexion in self.lineas:\n            if conexion[\"padre\"] == nodo or conexion[\"hijo\"] == nodo:\n                self.actualizar_conexion(conexion)\n        \n        for hijo in nodo[\"hijos\"]:\n            self.actualizar_conexiones_recursivas(hijo)\n\n    def finalizar_movimiento(self, event):\n        self.nodo_seleccionado = None\n\n    def mostrar_menu_contextual(self, event):\n        nodo_clickeado = self.encontrar_nodo(event.x, event.y)\n        \n        if nodo_clickeado:\n            self.nodo_seleccionado = nodo_clickeado\n            self.menu_nodo.post(event.x_root, event.y_root)\n        else:\n            self.menu_canvas.post(event.x_root, event.y_root)\n\n    def crear_nodo_matriz(self):\n        dialog = NodoConfigDialog(self.root, \"Configurar Nodo Matriz\")\n        if dialog.result:\n            nombre, tipo, datos_extra = dialog.result\n            x, y = 100, 100\n            self.crear_nodo(nombre, tipo, x, y, datos_extra)\n\n    def crear_nodo_hijo(self):\n        if not self.nodo_seleccionado:\n            return\n            \n        dialog = NodoConfigDialog(self.root, \"Configurar Nodo Hijo\")\n        if dialog.result:\n            nombre, tipo, datos_extra = dialog.result\n            coords = self.canvas.bbox(self.nodo_seleccionado[\"rect\"])\n            x = coords[0] + 200\n            y = coords[1] + 80\n            \n            nuevo_nodo = self.crear_nodo(nombre, tipo, x, y, datos_extra)\n            self.crear_conexion(self.nodo_seleccionado, nuevo_nodo)\n\n    def crear_nodo(self, nombre, tipo, x, y, datos_extra=None):\n        colores = {\n            \"carpeta\": \"#FFE5B4\",\n            \"imagen\": \"#E0FFE0\",\n            \"script\": \"#E0E0FF\",\n            \"archivo\": \"#FFFFFF\"\n        }\n        color = colores.get(tipo, \"#FFFFFF\")\n        \n        ancho_nodo = 300\n        alto_nodo = 40\n        rect = self.canvas.create_rectangle(x, y, x + ancho_nodo, y + alto_nodo, fill=color)\n        \n        icono_id = None\n        if tipo in self.iconos:\n            icono_id = self.canvas.create_image(x + 30, y + (alto_nodo/2), image=self.iconos[tipo])\n        \n        texto = self.canvas.create_text(x + 160, y + (alto_nodo/2), text=nombre)\n        \n        nodo = {\n            \"rect\": rect,\n            \"icono\": icono_id,\n            \"texto\": texto,\n            \"tipo\": tipo,\n            \"nombre\": nombre,\n            \"conexiones\": [],\n            \"hijos\": [],\n            \"datos_extra\": datos_extra or {}\n        }\n        \n        self.nodos.append(nodo)\n        return nodo\n\n    def crear_conexion(self, padre, hijo):\n        coords_padre = self.canvas.bbox(padre[\"rect\"])\n        coords_hijo = self.canvas.bbox(hijo[\"rect\"])\n        \n        x1 = (coords_padre[0] + coords_padre[2]) / 2\n        y1 = coords_padre[3]\n        \n        x2 = coords_hijo[0]\n        y2 = (coords_hijo[1] + coords_hijo[3]) / 2\n        \n        linea_vertical = self.canvas.create_line(x1, y1, x1, y2, width=2)\n        linea_horizontal = self.canvas.create_line(x1, y2, x2, y2, width=2)\n        \n        conexion = {\n            \"linea_vertical\": linea_vertical,\n            \"linea_horizontal\": linea_horizontal,\n            \"padre\": padre,\n            \"hijo\": hijo,\n            \"nivel_y\": y2\n        }\n        self.lineas.append(conexion)\n        \n        padre[\"hijos\"].append(hijo)\n        padre[\"conexiones\"].extend([linea_vertical, linea_horizontal])\n        hijo[\"conexiones\"].extend([linea_vertical, linea_horizontal])\n\n    def actualizar_conexion(self, conexion):\n        coords_padre = self.canvas.bbox(conexion[\"padre\"][\"rect\"])\n        coords_hijo = self.canvas.bbox(conexion[\"hijo\"][\"rect\"])\n        \n        x_padre = (coords_padre[0] + coords_padre[2]) / 2\n        y_padre = coords_padre[3]\n        \n        x_hijo = coords_hijo[0]\n        y_hijo = (coords_hijo[1] + coords_hijo[3]) / 2\n        \n        self.canvas.coords(conexion[\"linea_vertical\"], \n                         x_padre, y_padre, \n                         x_padre, y_hijo)\n        self.canvas.coords(conexion[\"linea_horizontal\"], \n                         x_padre, y_hijo, \n                         x_hijo, y_hijo)\n\n    def editar_nodo_actual(self):\n        if not self.nodo_seleccionado:\n            return\n            \n        dialog = NodoConfigDialog(\n            self.root, \n            \"Editar Nodo\",\n            inicial_nombre=self.nodo_seleccionado[\"nombre\"],\n            inicial_tipo=self.nodo_seleccionado[\"tipo\"],\n            inicial_datos=self.nodo_seleccionado[\"datos_extra\"]\n        )\n        \n        if dialog.result:\n            nombre, tipo, datos_extra = dialog.result\n            self.nodo_seleccionado[\"nombre\"] = nombre\n            self.nodo_seleccionado[\"tipo\"] = tipo\n            self.nodo_seleccionado[\"datos_extra\"] = datos_extra\n            \n            self.canvas.itemconfig(self.nodo_seleccionado[\"texto\"], text=nombre)\n            \n            if self.nodo_seleccionado[\"icono\"]:\n                self.canvas.delete(self.nodo_seleccionado[\"icono\"])\n            if tipo in self.iconos:\n                coords = self.canvas.bbox(self.nodo_seleccionado[\"rect\"])\n                self.nodo_seleccionado[\"icono\"] = self.canvas.create_image(\n                    coords[0] + 30, (coords[1] + coords[3])/2, \n                    image=self.iconos[tipo]\n                )\n            \n            colores = {\n                \"carpeta\": \"#FFE5B4\",\n                \"imagen\": \"#E0FFE0\",\n                \"script\": \"#E0E0FF\",\n                \"archivo\": \"#FFFFFF\"\n            }\n            self.canvas.itemconfig(\n                self.nodo_seleccionado[\"rect\"], \n                fill=colores.get(tipo, \"#FFFFFF\")\n            )\n\n    def eliminar_nodo_y_descendientes(self):\n        if not self.nodo_seleccionado:\n            return\n            \n        self.eliminar_nodo_recursivo(self.nodo_seleccionado)\n        self.nodo_seleccionado = None\n\n    def eliminar_nodo_recursivo(self, nodo):\n        for hijo in nodo[\"hijos\"][:]:\n            self.eliminar_nodo_recursivo(hijo)\n        \n        for linea in nodo[\"conexiones\"]:\n            self.canvas.delete(linea)\n        \n        self.lineas = [l for l in self.lineas \n                      if l[\"linea_vertical\"] not in nodo[\"conexiones\"] and \n                         l[\"linea_horizontal\"] not in nodo[\"conexiones\"]]\n        \n        self.canvas.delete(nodo[\"rect\"])\n        self.canvas.delete(nodo[\"texto\"])\n        if nodo.get(\"icono\"):\n            self.canvas.delete(nodo[\"icono\"])\n        \n        if nodo in self.nodos:\n            self.nodos.remove(nodo)\n\n    def guardar_estructura(self):\n        try:\n            datos = self.serializar_estructura()\n            \n            # Pre-procesar los datos para mantener el formato del código\n            for nodo in datos[\"nodos\"]:\n                if nodo[\"tipo\"] == \"script\" and \"datos_extra\" in nodo:\n                    # Asegurarse de que el contenido del script mantenga su formato\n                    contenido = nodo[\"datos_extra\"].get(\"contenido\", \"\")\n                    if isinstance(contenido, str):\n                        # Preservar la indentación y los saltos de línea\n                        nodo[\"datos_extra\"][\"contenido\"] = contenido.rstrip()\n            \n            filename = filedialog.asksaveasfilename(\n                defaultextension=\".json\",\n                filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")]\n            )\n            if filename:\n                with open(filename, 'w', encoding='utf-8') as f:\n                    json.dump(datos, f, indent=4, ensure_ascii=False)\n                messagebox.showinfo(\"Éxito\", \"Estructura guardada correctamente\")\n        \n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Error al guardar: {str(e)}\")\n\n# SUSTITUIR DESDE AQUÍ HASTA EL FINAL DEL ARCHIVO:\n\n    def serializar_estructura(self):\n        datos = {\n            \"nodos\": [],\n            \"conexiones\": []\n        }\n        \n        for nodo in self.nodos:\n            coords = self.canvas.coords(nodo[\"rect\"])\n            nodo_data = {\n                \"tipo\": nodo[\"tipo\"],\n                \"nombre\": nodo[\"nombre\"],\n                \"x\": coords[0],\n                \"y\": coords[1],\n                \"datos_extra\": {}\n            }\n            \n            # Manejar datos extra específicamente para mantener el formato\n            if nodo[\"tipo\"] == \"script\":\n                nodo_data[\"datos_extra\"] = {\n                    \"extension\": nodo[\"datos_extra\"].get(\"extension\", \".py\"),\n                    \"contenido\": nodo[\"datos_extra\"].get(\"contenido\", \"\").rstrip()\n                }\n            elif nodo[\"tipo\"] == \"imagen\":\n                nodo_data[\"datos_extra\"] = {\n                    \"ancho\": nodo[\"datos_extra\"].get(\"ancho\", 100),\n                    \"alto\": nodo[\"datos_extra\"].get(\"alto\", 100),\n                    \"ruta_original\": nodo[\"datos_extra\"].get(\"ruta_original\")\n                }\n            else:\n                nodo_data[\"datos_extra\"] = nodo[\"datos_extra\"]\n            \n            datos[\"nodos\"].append(nodo_data)\n        \n        for conexion in self.lineas:\n            origen_idx = self.nodos.index(conexion[\"padre\"])\n            destino_idx = self.nodos.index(conexion[\"hijo\"])\n            datos[\"conexiones\"].append({\n                \"padre\": origen_idx,\n                \"hijo\": destino_idx\n            })\n        \n        return datos\n\n    def cargar_estructura(self):\n        try:\n            filename = filedialog.askopenfilename(\n                filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")]\n            )\n            if not filename:\n                return\n            \n            # Limpiar canvas actual\n            self.canvas.delete(\"all\")\n            self.nodos = []\n            self.lineas = []\n            \n            # Cargar datos preservando formato\n            with open(filename, 'r', encoding='utf-8') as f:\n                datos = json.load(f)\n            \n            # Recrear nodos manteniendo el formato del contenido\n            for nodo_data in datos[\"nodos\"]:\n                # Pre-procesar datos extra para scripts\n                if nodo_data[\"tipo\"] == \"script\" and \"datos_extra\" in nodo_data:\n                    contenido = nodo_data[\"datos_extra\"].get(\"contenido\", \"\")\n                    if isinstance(contenido, str):\n                        nodo_data[\"datos_extra\"][\"contenido\"] = contenido\n                \n                self.crear_nodo(\n                    nodo_data[\"nombre\"],\n                    nodo_data[\"tipo\"],\n                    nodo_data[\"x\"],\n                    nodo_data[\"y\"],\n                    nodo_data.get(\"datos_extra\", {})\n                )\n            \n            # Recrear conexiones\n            for conn in datos[\"conexiones\"]:\n                padre = self.nodos[conn[\"padre\"]]\n                hijo = self.nodos[conn[\"hijo\"]]\n                self.crear_conexion(padre, hijo)\n            \n            messagebox.showinfo(\"Éxito\", \"Estructura cargada correctamente\")\n        \n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Error al cargar: {str(e)}\")\n\n    def generar_archivos(self):\n        if not self.nodos:\n            messagebox.showwarning(\"Aviso\", \"No hay estructura para generar\")\n            return\n            \n        # Pedir directorio base\n        dir_base = filedialog.askdirectory(title=\"Seleccionar directorio base\")\n        if not dir_base:\n            return\n            \n        try:\n            # Encontrar nodos raíz\n            nodos_raiz = []\n            for nodo in self.nodos:\n                es_hijo = False\n                for conexion in self.lineas:\n                    if conexion[\"hijo\"] == nodo:\n                        es_hijo = True\n                        break\n                if not es_hijo:\n                    nodos_raiz.append(nodo)\n            \n            if not nodos_raiz:\n                messagebox.showwarning(\"Aviso\", \"No se encontraron nodos raíz\")\n                return\n            \n            # Generar estructura para cada nodo raíz\n            for nodo in nodos_raiz:\n                self.generar_estructura_recursiva(nodo, dir_base)\n            \n            messagebox.showinfo(\"Éxito\", \"Estructura de archivos generada correctamente\")\n        \n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Error al generar estructura: {str(e)}\")\n\n    def generar_estructura_recursiva(self, nodo, path_actual):\n        try:\n            nombre_seguro = \"\".join(c for c in nodo[\"nombre\"] if c.isalnum() or c in (' ', '-', '_', '.'))\n            path_completo = os.path.join(path_actual, nombre_seguro)\n            \n            if nodo[\"tipo\"] == \"carpeta\":\n                os.makedirs(path_completo, exist_ok=True)\n                for hijo in nodo[\"hijos\"]:\n                    self.generar_estructura_recursiva(hijo, path_completo)\n            else:\n                try:\n                    if nodo[\"tipo\"] == \"imagen\":\n                        datos_extra = nodo.get(\"datos_extra\", {})\n                        ruta_original = datos_extra.get(\"ruta_original\")\n                        if ruta_original and os.path.exists(ruta_original):\n                            # Si tenemos la ruta original y existe, copiamos el archivo\n                            import shutil\n                            shutil.copy2(ruta_original, path_completo)\n                        else:\n                            # Si no tenemos la ruta original, creamos una imagen en blanco\n                            ancho = int(datos_extra.get(\"ancho\", 100))\n                            alto = int(datos_extra.get(\"alto\", 100))\n                            Image.new('RGB', (ancho, alto), 'white').save(path_completo)\n                    \n                    elif nodo[\"tipo\"] == \"script\":\n                        datos_extra = nodo.get(\"datos_extra\", {})\n                        contenido = datos_extra.get(\"contenido\", \"\")\n                        if not isinstance(contenido, str):\n                            contenido = str(contenido)\n                        with open(path_completo, 'w', encoding='utf-8') as f:\n                            f.write(contenido)\n                    \n                    else:\n                        open(path_completo, 'a').close()\n                \n                except Exception as e:\n                    messagebox.showerror(\"Error\", f\"Error al crear {nombre_seguro}: {str(e)}\")\n        \n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Error al generar estructura: {str(e)}\")\n\n\nclass NodoConfigDialog:\n    def __init__(self, parent, titulo, inicial_nombre=\"\", inicial_tipo=\"archivo\", inicial_datos=None):\n        self.result = None\n        self.imagen_data = None\n        \n        # Crear diálogo\n        self.dialog = tk.Toplevel(parent)\n        self.dialog.title(titulo)\n        self.dialog.transient(parent)\n        self.dialog.grab_set()\n        \n        # Aumentar el tamaño inicial del diálogo\n        self.dialog.geometry('600x700')\n        \n        # Frame principal\n        main_frame = ttk.Frame(self.dialog, padding=\"10\")\n        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        \n        # Configurar expansión del grid\n        self.dialog.grid_rowconfigure(0, weight=1)\n        self.dialog.grid_columnconfigure(0, weight=1)\n        main_frame.grid_columnconfigure(1, weight=1)\n        \n        # Campos básicos\n        ttk.Label(main_frame, text=\"Nombre:\").grid(row=0, column=0, sticky=tk.W, pady=5)\n        self.nombre = ttk.Entry(main_frame, width=50)\n        self.nombre.grid(row=0, column=1, columnspan=2, sticky=tk.W+tk.E, pady=5)\n        self.nombre.insert(0, inicial_nombre)\n        \n        ttk.Label(main_frame, text=\"Tipo:\").grid(row=1, column=0, sticky=tk.W, pady=5)\n        self.tipo = ttk.Combobox(main_frame, \n                                values=[\"archivo\", \"carpeta\", \"imagen\", \"script\"],\n                                state=\"readonly\", width=47)\n        self.tipo.grid(row=1, column=1, columnspan=2, sticky=tk.W+tk.E, pady=5)\n        self.tipo.set(inicial_tipo)\n        \n        # Frame para campos adicionales\n        self.frame_extra = ttk.Frame(main_frame)\n        self.frame_extra.grid(row=2, column=0, columnspan=3, sticky=tk.W+tk.E+tk.N+tk.S, pady=10)\n        self.frame_extra.grid_columnconfigure(1, weight=1)\n        \n        # Configurar campos según tipo\n        self.campos_extra = {}\n        self.tipo.bind('<<ComboboxSelected>>', self.actualizar_campos_extra)\n        \n        # Botones\n        frame_botones = ttk.Frame(main_frame)\n        frame_botones.grid(row=3, column=0, columnspan=3, pady=10)\n        \n        ttk.Button(frame_botones, text=\"Aceptar\", \n                  command=self.finalizar).pack(side=tk.LEFT, padx=5)\n        ttk.Button(frame_botones, text=\"Cancelar\", \n                  command=self.dialog.destroy).pack(side=tk.LEFT, padx=5)\n        \n        # Inicializar campos extra\n        self.tipo.set(inicial_tipo)\n        self.actualizar_campos_extra(None)\n        if inicial_datos:\n            self.cargar_datos_iniciales(inicial_datos)\n        \n        # Hacer foco en el campo nombre\n        self.nombre.focus_set()\n        \n        # Esperar hasta que se cierre el diálogo\n        self.dialog.wait_window()\n\n    def actualizar_campos_extra(self, event):\n        # Limpiar frame actual\n        for widget in self.frame_extra.winfo_children():\n            widget.destroy()\n        self.campos_extra.clear()\n        \n        tipo_actual = self.tipo.get()\n        \n        if tipo_actual == \"imagen\":\n            ttk.Label(self.frame_extra, text=\"Dimensiones:\").grid(row=0, column=0, sticky=tk.W, padx=5)\n            \n            frame_dim = ttk.Frame(self.frame_extra)\n            frame_dim.grid(row=0, column=1, sticky=tk.W, pady=5)\n            \n            self.campos_extra[\"ancho\"] = ttk.Entry(frame_dim, width=8)\n            self.campos_extra[\"ancho\"].pack(side=tk.LEFT, padx=2)\n            ttk.Label(frame_dim, text=\"x\").pack(side=tk.LEFT, padx=2)\n            self.campos_extra[\"alto\"] = ttk.Entry(frame_dim, width=8)\n            self.campos_extra[\"alto\"].pack(side=tk.LEFT, padx=2)\n            \n            ttk.Button(self.frame_extra, text=\"Seleccionar Imagen\",\n                      command=self.seleccionar_imagen).grid(row=1, column=0, \n                                                          columnspan=2, pady=10)\n            \n        elif tipo_actual == \"script\":\n            ttk.Label(self.frame_extra, text=\"Extensión:\").grid(row=0, column=0, sticky=tk.W, padx=5)\n            self.campos_extra[\"extension\"] = ttk.Combobox(\n                self.frame_extra,\n                values=[\".py\", \".js\", \".sh\", \".sql\", \".html\", \".css\"],\n                state=\"readonly\",\n                width=15\n            )\n            self.campos_extra[\"extension\"].grid(row=0, column=1, sticky=tk.W, pady=5)\n            self.campos_extra[\"extension\"].set(\".py\")\n            \n            ttk.Label(self.frame_extra, text=\"Contenido:\").grid(row=1, column=0, \n                                                              sticky=tk.W, padx=5, pady=5)\n            \n            self.campos_extra[\"contenido\"] = tk.Text(self.frame_extra, \n                                                   height=30, width=60, \n                                                   wrap=tk.NONE)  # Desactivar wrap\n            self.campos_extra[\"contenido\"].grid(row=2, column=0, columnspan=2, \n                                             sticky=tk.W+tk.E+tk.N+tk.S, padx=5)\n            \n            # Scrollbars para el texto\n            scrollbar_v = ttk.Scrollbar(self.frame_extra, \n                                    orient=\"vertical\", \n                                    command=self.campos_extra[\"contenido\"].yview)\n            scrollbar_v.grid(row=2, column=2, sticky=tk.N+tk.S)\n            \n            scrollbar_h = ttk.Scrollbar(self.frame_extra,\n                                    orient=\"horizontal\",\n                                    command=self.campos_extra[\"contenido\"].xview)\n            scrollbar_h.grid(row=3, column=0, columnspan=2, sticky=tk.E+tk.W)\n            \n            self.campos_extra[\"contenido\"][\"yscrollcommand\"] = scrollbar_v.set\n            self.campos_extra[\"contenido\"][\"xscrollcommand\"] = scrollbar_h.set\n\n    def cargar_datos_iniciales(self, datos):\n        tipo = self.tipo.get()\n        if tipo == \"imagen\":\n            self.imagen_data = datos.get(\"imagen_data\")\n            self.campos_extra[\"ancho\"].insert(0, str(datos.get(\"ancho\", \"100\")))\n            self.campos_extra[\"alto\"].insert(0, str(datos.get(\"alto\", \"100\")))\n        elif tipo == \"script\":\n            self.campos_extra[\"extension\"].set(datos.get(\"extension\", \".py\"))\n            contenido = datos.get(\"contenido\", \"\")\n            if isinstance(contenido, str):\n                self.campos_extra[\"contenido\"].insert(\"1.0\", contenido)\n\n    def seleccionar_imagen(self):\n            filename = filedialog.askopenfilename(\n                filetypes=[\n                    (\"Imágenes\", \"*.png *.jpg *.jpeg *.gif *.bmp\"),\n                    (\"Todos los archivos\", \"*.*\")\n                ]\n            )\n            if filename:\n                try:\n                    imagen = Image.open(filename)\n                    self.campos_extra[\"ancho\"].delete(0, tk.END)\n                    self.campos_extra[\"ancho\"].insert(0, str(imagen.width))\n                    self.campos_extra[\"alto\"].delete(0, tk.END)\n                    self.campos_extra[\"alto\"].insert(0, str(imagen.height))\n                    # Guardamos la ruta del archivo original\n                    self.imagen_path = filename\n                except Exception as e:\n                    messagebox.showerror(\"Error\", f\"Error al cargar la imagen: {str(e)}\")\n\n    def finalizar(self):\n        nombre = self.nombre.get().strip()\n        if not nombre:\n            messagebox.showerror(\"Error\", \"El nombre no puede estar vacío\")\n            return\n        \n        tipo = self.tipo.get()\n        datos_extra = {}\n        \n        if tipo == \"imagen\":\n            try:\n                ancho = int(self.campos_extra[\"ancho\"].get())\n                alto = int(self.campos_extra[\"alto\"].get())\n                datos_extra = {\n                    \"ancho\": ancho,\n                    \"alto\": alto,\n                    \"ruta_original\": getattr(self, 'imagen_path', None)  # Guardamos la ruta si existe\n                }\n            except ValueError:\n                messagebox.showerror(\"Error\", \"Las dimensiones deben ser números enteros\")\n                return\n                \n        elif tipo == \"script\":\n            contenido = self.campos_extra[\"contenido\"].get(\"1.0\", \"end-1c\")\n            datos_extra = {\n                \"extension\": self.campos_extra[\"extension\"].get(),\n                \"contenido\": contenido\n            }\n            nombre = nombre + datos_extra[\"extension\"]\n        \n        self.result = (nombre, tipo, datos_extra)\n        self.dialog.destroy()\n\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = VisorArchivos(root)\n    root.mainloop()"
            }
        },
        {
            "tipo": "imagen",
            "nombre": "folder",
            "x": 375.0,
            "y": 215.0,
            "datos_extra": {
                "ancho": 32,
                "alto": 32,
                "ruta_original": "C:/Users/Cross/Desktop/root/Board_AI_Developer/folder.png"
            }
        },
        {
            "tipo": "imagen",
            "nombre": "image",
            "x": 375.0,
            "y": 274.0,
            "datos_extra": {
                "ancho": 32,
                "alto": 32,
                "ruta_original": "C:/Users/Cross/Desktop/root/Board_AI_Developer/image.png"
            }
        },
        {
            "tipo": "imagen",
            "nombre": "script",
            "x": 375.0,
            "y": 333.0,
            "datos_extra": {
                "ancho": 32,
                "alto": 32,
                "ruta_original": "C:/Users/Cross/Desktop/root/Board_AI_Developer/script.png"
            }
        }
    ],
    "conexiones": [
        {
            "padre": 0,
            "hijo": 1
        },
        {
            "padre": 0,
            "hijo": 2
        },
        {
            "padre": 0,
            "hijo": 3
        },
        {
            "padre": 0,
            "hijo": 4
        }
    ]
}